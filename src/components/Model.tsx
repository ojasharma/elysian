/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/model.glb --types 
Author: Gohar.Munir (https://sketchfab.com/Gohar.Munir)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/low-poly-jigsaw-puzzle-pieces-16dc224022e141409982c82c5e88f8d4
Title: Low Poly Jigsaw Puzzle Pieces
*/

import * as THREE from 'three';
// Import useRef for mesh references, useMemo to calculate random values once, and useFrame for animation
import React, { ComponentProps, useRef, useMemo } from 'react';
import { useGLTF } from '@react-three/drei';
import { useFrame } from '@react-three/fiber'; // <-- Import the useFrame hook
import { GLTF } from 'three-stdlib';

type GLTFResult = GLTF & {
  nodes: {
    Puzzle_Piece_1__0: THREE.Mesh;
    Puzzle_Piece_2_008802_0: THREE.Mesh;
    Puzzle_Piece_3_D31E29_0: THREE.Mesh;
    Puzzle_Piece_4_1E5AD8_0: THREE.Mesh;
    Puzzle_Piece_5_FFC107_0: THREE.Mesh;
  };
  materials: {
    Puzzle_Piece_1__0: THREE.MeshStandardMaterial;
    ['008802']: THREE.MeshStandardMaterial;
    D31E29: THREE.MeshStandardMaterial;
    ['1E5AD8']: THREE.MeshStandardMaterial;
    FFC107: THREE.MeshStandardMaterial;
  };
};

export function Model(props: ComponentProps<'group'>) {
  const { nodes, materials } = useGLTF('/model.glb') as unknown as GLTFResult;

  // STEP 1: Create a ref object to hold references to our meshes
  const meshRefs = useRef<{ [key: string]: THREE.Mesh | null }>({});

  // STEP 2: Use useMemo to define the puzzle pieces configuration
  // This ensures the random speeds are generated only once.
  const puzzlePieces = useMemo(
    () => [
      {
        name: 'Piece_2',
        geometry: nodes.Puzzle_Piece_2_008802_0.geometry,
        material: materials['008802'],
        position: [190, 200, 0] as [number, number, number],
        // Add a new property for randomized rotation speed [x, y, z]
        // (Math.random() - 0.5) gives a value between -0.5 and 0.5 for rotation in both directions
        rotationSpeed: [(Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5] as const,
      },
      {
        name: 'Piece_3',
        geometry: nodes.Puzzle_Piece_3_D31E29_0.geometry,
        material: materials.D31E29,
        position: [240, -190, 0] as [number, number, number],
        rotationSpeed: [(Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5] as const,
      },
      {
        name: 'Piece_4',
        geometry: nodes.Puzzle_Piece_4_1E5AD8_0.geometry,
        material: materials['1E5AD8'],
        position: [-290, -200, 0] as [number, number, number],
        rotationSpeed: [(Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5] as const,
      },
      {
        name: 'Piece_5',
        geometry: nodes.Puzzle_Piece_5_FFC107_0.geometry,
        material: materials.FFC107,
        position: [-160, 210, 0] as [number, number, number],
        rotationSpeed: [(Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5] as const,
      },
    ],
    [nodes, materials]
  );

  // STEP 3: Use the useFrame hook for animation
  useFrame((state, delta) => {
    // Loop through each piece on every frame
    puzzlePieces.forEach((piece) => {
      const mesh = meshRefs.current[piece.name];
      if (mesh) {
        // Update the rotation on each axis
        // 'delta' ensures the animation is smooth regardless of frame rate
        mesh.rotation.x += piece.rotationSpeed[0] * delta;
        mesh.rotation.y += piece.rotationSpeed[1] * delta;
        mesh.rotation.z += piece.rotationSpeed[2] * delta;
      }
    });
  });

  return (
    <group {...props} dispose={null}>
      <group scale={0.01}>
        {puzzlePieces.map((piece) => (
          <mesh
            key={piece.name}
            // STEP 4: Assign the ref to the mesh element
            ref={(el) => (meshRefs.current[piece.name] = el)}
            geometry={piece.geometry}
            material={piece.material}
            position={piece.position}
            // We no longer need the static rotation prop here, as useFrame is controlling it
          />
        ))}
      </group>
    </group>
  );
}

useGLTF.preload('/model.glb');