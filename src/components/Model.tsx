/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/model.glb --types 
Author: Gohar.Munir (https://sketchfab.com/Gohar.Munir)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/low-poly-jigsaw-puzzle-pieces-16dc224022e141409982c82c5e88f8d4
Title: Low Poly Jigsaw Puzzle Pieces
*/

import * as THREE from 'three';
import React, { ComponentProps, useRef, useMemo, useState, useEffect } from 'react';
import { useGLTF } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';
import { GLTF } from 'three-stdlib';

type GLTFResult = GLTF & {
  nodes: {
    Puzzle_Piece_1__0: THREE.Mesh;
    Puzzle_Piece_2_008802_0: THREE.Mesh;
    Puzzle_Piece_3_D31E29_0: THREE.Mesh;
    Puzzle_Piece_4_1E5AD8_0: THREE.Mesh;
    Puzzle_Piece_5_FFC107_0: THREE.Mesh;
  };
  materials: {
    Puzzle_Piece_1__0: THREE.MeshStandardMaterial;
    ['008802']: THREE.MeshStandardMaterial;
    D31E29: THREE.MeshStandardMaterial;
    ['1E5AD8']: THREE.MeshStandardMaterial;
    FFC107: THREE.MeshStandardMaterial;
  };
};

// Custom hook to check if the screen is mobile-sized
const useIsMobile = (breakpoint = 768) => {
  const [isMobile, setIsMobile] = useState(false);

  useEffect(() => {
    const checkScreenSize = () => {
      setIsMobile(window.innerWidth < breakpoint);
    };
    checkScreenSize();
    window.addEventListener('resize', checkScreenSize);
    return () => window.removeEventListener('resize', checkScreenSize);
  }, [breakpoint]);

  return isMobile;
};


export function Model(props: ComponentProps<'group'>) {
  const { nodes, materials } = useGLTF('/model.glb') as unknown as GLTFResult;
  const isMobile = useIsMobile();
  const meshRefs = useRef<{ [key: string]: THREE.Mesh | null }>({});

  const puzzlePieces = useMemo(
    () => [
      {
        name: 'Piece_2',
        geometry: nodes.Puzzle_Piece_2_008802_0.geometry,
        material: materials['008802'],
        position: isMobile
          ? ([100,100, 0] as [number, number, number])
          : ([500, 180, 0] as [number, number, number]),
        // NEW: Add a scale property. 1 is default size, 0.8 is 80% of the size.
        scale: isMobile ? 0.5 : 1, // <-- CHANGE MOBILE/DESKTOP SIZE HERE
        rotationSpeed: [(Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5] as const,
      },
      {
        name: 'Piece_3',
        geometry: nodes.Puzzle_Piece_3_D31E29_0.geometry,
        material: materials.D31E29,
        position: isMobile
          ? ([120, -85, 0] as [number, number, number])
          : ([500, -180, 0] as [number, number, number]),
        scale: isMobile ? 0.5 : 1, // <-- CHANGE MOBILE/DESKTOP SIZE HERE
        rotationSpeed: [(Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5] as const,
      },
      {
        name: 'Piece_4',
        geometry: nodes.Puzzle_Piece_4_1E5AD8_0.geometry,
        material: materials['1E5AD8'],
        position: isMobile
          ? ([-120, -90, 0] as [number, number, number])
          : ([-500, -170, 0] as [number, number, number]),
        scale: isMobile ? 0.5 : 1, // <-- CHANGE MOBILE/DESKTOP SIZE HERE
        rotationSpeed: [(Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5] as const,
      },
      {
        name: 'Piece_5',
        geometry: nodes.Puzzle_Piece_5_FFC107_0.geometry,
        material: materials.FFC107,
        position: isMobile
          ? ([-90, 100, 0] as [number, number, number])
          : ([-500, 180, 0] as [number, number, number]),
        scale: isMobile ? 0.5 : 1, // <-- CHANGE MOBILE/DESKTOP SIZE HERE
        rotationSpeed: [(Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5, (Math.random() - 0.5) * 0.5] as const,
      },
    ],
    [nodes, materials, isMobile]
  );

  useFrame((state, delta) => {
    puzzlePieces.forEach((piece) => {
      const mesh = meshRefs.current[piece.name];
      if (mesh) {
        mesh.rotation.x += piece.rotationSpeed[0] * delta;
        mesh.rotation.y += piece.rotationSpeed[1] * delta;
        mesh.rotation.z += piece.rotationSpeed[2] * delta;
      }
    });
  });

  return (
    <group {...props} dispose={null}>
      <group scale={0.01}>
        {puzzlePieces.map((piece) => (
          <mesh
            key={piece.name}
            ref={(el) => (meshRefs.current[piece.name] = el)}
            geometry={piece.geometry}
            material={piece.material}
            position={piece.position}
            scale={piece.scale} // <-- Add the scale prop here
          />
        ))}
      </group>
    </group>
  );
}

useGLTF.preload('/model.glb');